/*
 * ResultsFrame.java
 *
 * Created on July 3, 2008, 2:21 PM
 */

package minoe;

import minoe.ResultsFrame.ComboBoxRenderer;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Font;
import java.awt.Rectangle;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JSpinner;
import javax.swing.JTable;
import javax.swing.ListCellRenderer;
import javax.swing.SwingWorker;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;

/**
 * Displays a window of ResultPanels.
 * @author  Dan Spiteri
 */
public class ResultsFrame extends javax.swing.JInternalFrame {
    
    CustomDesktopPane parentOwner;  // parent container
    
    Vector<CustomTableModel> dataModels; // all of the table data from each tab pane.
    Vector<SearchCriteria> searchCriteria;
    Vector<ResultPanel> resultPanels;

    public StatusFrame sf;
    
    boolean finish = false;
    
    private int totalPanels = 0;  // default
        
    private String[] columnNames;
    static private float[][] gapLinkages; // passed in from GapsPanel2
    public float[][] listLinkages = null;
    
    private Task task;
    
    Color gapsColor = Color.RED;
    Color linkagesColor = Color.CYAN;
    Color fontColor = Color.BLACK;
    
    String defaultGapsColor = "RED";
    String defaultLinkagesColor = "CYAN";
    String defaultFontColor = "BLACK";
    
    public int fontSize = 12;
    
    public String[] colorChoices = {
            "",
            "BLACK", 
            "BLUE", 
            "CYAN", 
            "DARK GRAY", 
            "GRAY", 
            "GREEN", 
            "LIGHT GRAY",
            "MAGENTA",
            "ORANGE",
            "PINK",
            "RED",
            "WHITE",
            "YELLOW"            
     };
    
    /**
     * 
     * @param owner
     * @param columns
     * @param linkages
     * @param searchCriteria
     */
    public ResultsFrame(CustomDesktopPane owner, String[] columns, float[][] linkages, Vector<SearchCriteria> searchCriteria) {
        this.parentOwner = owner;      
        this.columnNames = columns;
        this.gapLinkages = linkages;
        this.searchCriteria = searchCriteria;
        this.dataModels = new Vector();
        this.resultPanels = new Vector();
        
        // GUI options
        initComponents(); 
        this.setCenter();
        
        this.sf = new StatusFrame(this);
        
        // Crunch the data and build the GUI using a swing worker in the background.
        task = new Task();
        task.execute();
       
        linkagesColorCombo.setSelectedItem(this.defaultLinkagesColor);
        gapColorCombo.setSelectedItem(this.defaultGapsColor);
        fontColorCombo.setSelectedItem(this.defaultFontColor);
        
        this.finish = true; // this flag will prevent the actionperformed methods 
                            // from trying to update the component before the frame is rendered.
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        contentPanel = new javax.swing.JPanel();
        buttonPanel = new javax.swing.JPanel();
        optionsPanel = new javax.swing.JPanel();
        gapsColorLabel = new javax.swing.JLabel();
        gapColorCombo = new javax.swing.JComboBox(this.colorChoices);
        linkagesColorLabel = new javax.swing.JLabel();
        linkagesColorCombo = new javax.swing.JComboBox(this.colorChoices);
        fontColorLabel = new javax.swing.JLabel();
        fontColorCombo = new javax.swing.JComboBox(this.colorChoices);
        fontSizeLabel = new javax.swing.JLabel();
        fontSpinner = new JSpinner();
        optionBox = new javax.swing.JComboBox();
        selectPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        selectAllCheckBox = new javax.swing.JCheckBox();
        selectLinkagesCheckBox = new javax.swing.JCheckBox();
        selectNonLinkagesCheckBox = new javax.swing.JCheckBox();
        selectDiagonalsCheckBox = new javax.swing.JCheckBox();
        tabPanel = new javax.swing.JPanel();
        tabPane = new javax.swing.JTabbedPane();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        saveAsExcelMenuItem = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        jSeparator5 = new javax.swing.JSeparator();
        saveTDMMenuItem = new javax.swing.JMenuItem();
        jSeparator3 = new javax.swing.JSeparator();
        closeMenuItem = new javax.swing.JMenuItem();
        viewMenu = new javax.swing.JMenu();
        graphMenuItem = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JSeparator();
        runCalcsMenu = new javax.swing.JMenu();
        allCalcMenuItem = new javax.swing.JMenuItem();
        currentPanelCalcMenuItem = new javax.swing.JMenuItem();
        jSeparator4 = new javax.swing.JSeparator();
        selectedCellsMenu = new javax.swing.JMenu();
        viewAgenciesMenuItem = new javax.swing.JMenuItem();
        viewDocumentsMenuItem = new javax.swing.JMenuItem();

        setClosable(true);
        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setIconifiable(true);
        setMaximizable(true);
        setResizable(true);
        setTitle(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.title")); // NOI18N
        setFrameIcon(new javax.swing.ImageIcon(getClass().getResource("/minoe/greenbutton.png"))); // NOI18N
        setMinimumSize(new java.awt.Dimension(200, 100));
        setPreferredSize(new java.awt.Dimension(700, 600));
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));

        contentPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));
        contentPanel.setLayout(new javax.swing.BoxLayout(contentPanel, javax.swing.BoxLayout.Y_AXIS));

        buttonPanel.setMaximumSize(new java.awt.Dimension(32767, 100));
        buttonPanel.setMinimumSize(new java.awt.Dimension(700, 72));
        buttonPanel.setPreferredSize(new java.awt.Dimension(700, 75));
        buttonPanel.setLayout(new javax.swing.BoxLayout(buttonPanel, javax.swing.BoxLayout.LINE_AXIS));

        optionsPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.optionsPanel.border.title"), javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Arial", 0, 11))); // NOI18N
        optionsPanel.setFont(new java.awt.Font("Arial", 0, 11));
        optionsPanel.setMinimumSize(new java.awt.Dimension(700, 65));
        optionsPanel.setPreferredSize(new java.awt.Dimension(700, 62));
        optionsPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        gapsColorLabel.setFont(new java.awt.Font("Arial", 0, 12));
        gapsColorLabel.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.gapsColorLabel.text")); // NOI18N
        optionsPanel.add(gapsColorLabel);

        gapColorCombo.setFont(new java.awt.Font("Arial", 0, 12));
        gapColorCombo.setRenderer(new ComboBoxRenderer());

        gapColorCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gapColorComboActionPerformed(evt);
            }
        });
        optionsPanel.add(gapColorCombo);

        linkagesColorLabel.setFont(new java.awt.Font("Arial", 0, 12));
        linkagesColorLabel.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.linkagesColorLabel.text")); // NOI18N
        optionsPanel.add(linkagesColorLabel);

        linkagesColorCombo.setFont(new java.awt.Font("Arial", 0, 12));
        linkagesColorCombo.setRenderer(new ComboBoxRenderer());
        linkagesColorCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                linkagesColorComboActionPerformed(evt);
            }
        });
        optionsPanel.add(linkagesColorCombo);

        fontColorLabel.setFont(new java.awt.Font("Arial", 0, 12));
        fontColorLabel.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.fontColorLabel.text")); // NOI18N
        optionsPanel.add(fontColorLabel);

        fontColorCombo.setFont(new java.awt.Font("Arial", 0, 12));
        fontColorCombo.setRenderer(new ComboBoxRenderer());

        fontColorCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fontColorComboActionPerformed(evt);
            }
        });
        optionsPanel.add(fontColorCombo);

        fontSizeLabel.setFont(new java.awt.Font("Arial", 0, 12));
        fontSizeLabel.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.fontSizeLabel.text")); // NOI18N
        optionsPanel.add(fontSizeLabel);

        fontSpinner.setFont(new java.awt.Font("Arial", 0, 12));
        fontSpinner.setModel(new javax.swing.SpinnerNumberModel(12, 1, 48, 1));
        fontSpinner.addChangeListener(new SpinnerListener(this));
        optionsPanel.add(fontSpinner);

        optionBox.setFont(new java.awt.Font("Arial", 0, 12));
        optionBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Table Options...", "Auto Fit Columns", "Compact Columns" }));
        optionBox.setMinimumSize(new java.awt.Dimension(130, 20));
        optionBox.setPreferredSize(new java.awt.Dimension(130, 22));
        optionBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                optionBoxActionPerformed(evt);
            }
        });
        optionsPanel.add(optionBox);

        buttonPanel.add(optionsPanel);

        contentPanel.add(buttonPanel);

        selectPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.selectPanel.border.title"), javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Arial", 0, 11))); // NOI18N
        selectPanel.setMaximumSize(new java.awt.Dimension(32767, 70));
        selectPanel.setMinimumSize(new java.awt.Dimension(346, 50));
        selectPanel.setPreferredSize(new java.awt.Dimension(100, 70));
        selectPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 10, 5));

        jLabel1.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.jLabel1.text")); // NOI18N
        selectPanel.add(jLabel1);

        selectAllCheckBox.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.selectAllCheckBox.text")); // NOI18N
        selectAllCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectAllCheckBoxActionPerformed(evt);
            }
        });
        selectPanel.add(selectAllCheckBox);

        selectLinkagesCheckBox.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.selectLinkagesCheckBox.text")); // NOI18N
        selectLinkagesCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectLinkagesCheckBoxActionPerformed(evt);
            }
        });
        selectPanel.add(selectLinkagesCheckBox);

        selectNonLinkagesCheckBox.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.selectNonLinkagesCheckBox.text")); // NOI18N
        selectNonLinkagesCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectNonLinkagesCheckBoxActionPerformed(evt);
            }
        });
        selectPanel.add(selectNonLinkagesCheckBox);

        selectDiagonalsCheckBox.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.selectDiagonalsCheckBox.text")); // NOI18N
        selectDiagonalsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectDiagonalsCheckBoxActionPerformed(evt);
            }
        });
        selectPanel.add(selectDiagonalsCheckBox);

        contentPanel.add(selectPanel);

        tabPanel.setMinimumSize(new java.awt.Dimension(500, 200));
        tabPanel.setPreferredSize(new java.awt.Dimension(500, 200));
        tabPanel.setLayout(new javax.swing.BoxLayout(tabPanel, javax.swing.BoxLayout.Y_AXIS));

        tabPane.setTabLayoutPolicy(javax.swing.JTabbedPane.SCROLL_TAB_LAYOUT);
        tabPane.setAutoscrolls(true);
        tabPane.setFont(new java.awt.Font("Dialog", 0, 14));
        tabPane.setMinimumSize(new java.awt.Dimension(500, 200));
        tabPane.setOpaque(true);
        tabPane.setPreferredSize(new java.awt.Dimension(500, 200));
        tabPanel.add(tabPane);
        tabPane.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.jTabbedPane1.AccessibleContext.accessibleName")); // NOI18N

        contentPanel.add(tabPanel);

        getContentPane().add(contentPanel);

        fileMenu.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.fileMenu.text")); // NOI18N
        fileMenu.setFont(new java.awt.Font("Arial", 0, 11));

        saveAsExcelMenuItem.setFont(new java.awt.Font("Arial", 0, 11)); // NOI18N
        saveAsExcelMenuItem.setIcon(new javax.swing.ImageIcon(getClass().getResource("/minoe/45.png"))); // NOI18N
        saveAsExcelMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.saveAsExcelMenuItem.text")); // NOI18N
        saveAsExcelMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveAsExcelMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveAsExcelMenuItem);

        saveMenuItem.setFont(new java.awt.Font("Arial", 0, 11)); // NOI18N
        saveMenuItem.setIcon(new javax.swing.ImageIcon(getClass().getResource("/minoe/45.png"))); // NOI18N
        saveMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.saveMenuItem.text")); // NOI18N
        saveMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveMenuItem);
        fileMenu.add(jSeparator5);

        saveTDMMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.saveTDMMenuItem.text")); // NOI18N
        saveTDMMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveTDMMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveTDMMenuItem);
        fileMenu.add(jSeparator3);

        closeMenuItem.setFont(new java.awt.Font("Arial", 0, 11)); // NOI18N
        closeMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.closeMenuItem.text")); // NOI18N
        closeMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(closeMenuItem);

        menuBar.add(fileMenu);

        viewMenu.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.viewMenu.text")); // NOI18N
        viewMenu.setFont(new java.awt.Font("Arial", 0, 11));

        graphMenuItem.setFont(new java.awt.Font("Arial", 0, 11));
        graphMenuItem.setIcon(new javax.swing.ImageIcon(getClass().getResource("/minoe/33.png"))); // NOI18N
        graphMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.graphMenuItem.text")); // NOI18N
        graphMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                graphMenuItemActionPerformed(evt);
            }
        });
        viewMenu.add(graphMenuItem);
        viewMenu.add(jSeparator2);

        runCalcsMenu.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.runCalcsMenu.text")); // NOI18N
        runCalcsMenu.setFont(new java.awt.Font("Arial", 0, 11));

        allCalcMenuItem.setFont(new java.awt.Font("Arial", 0, 11));
        allCalcMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.allCalcMenuItem.text")); // NOI18N
        allCalcMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                allCalcMenuItemActionPerformed(evt);
            }
        });
        runCalcsMenu.add(allCalcMenuItem);

        currentPanelCalcMenuItem.setFont(new java.awt.Font("Arial", 0, 11));
        currentPanelCalcMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.currentPanelCalcMenuItem.text")); // NOI18N
        currentPanelCalcMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                currentPanelCalcMenuItemActionPerformed(evt);
            }
        });
        runCalcsMenu.add(currentPanelCalcMenuItem);

        viewMenu.add(runCalcsMenu);
        viewMenu.add(jSeparator4);

        selectedCellsMenu.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.selectedCellsMenu.text")); // NOI18N

        viewAgenciesMenuItem.setFont(new java.awt.Font("Arial", 0, 11));
        viewAgenciesMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.viewAgenciesMenuItem.text")); // NOI18N
        viewAgenciesMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                viewAgenciesMenuItemActionPerformed(evt);
            }
        });
        selectedCellsMenu.add(viewAgenciesMenuItem);

        viewDocumentsMenuItem.setFont(new java.awt.Font("Arial", 0, 11));
        viewDocumentsMenuItem.setText(org.openide.util.NbBundle.getMessage(ResultsFrame.class, "ResultsFrame.viewDocumentsMenuItem.text")); // NOI18N
        viewDocumentsMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                viewDocumentsMenuItemActionPerformed(evt);
            }
        });
        selectedCellsMenu.add(viewDocumentsMenuItem);

        viewMenu.add(selectedCellsMenu);

        menuBar.add(viewMenu);

        setJMenuBar(menuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents


    private void saveMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveMenuItemActionPerformed
        ResultPanel resultPanel = (ResultPanel) this.tabPane.getSelectedComponent();
        resultPanel.saveData();
}//GEN-LAST:event_saveMenuItemActionPerformed

    private void optionBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_optionBoxActionPerformed
        String selectedOption = (String) this.optionBox.getSelectedItem();
        ResultPanel r = (ResultPanel) this.tabPane.getSelectedComponent();
        if (selectedOption.equals("Auto Fit Columns")){
            r.autoFitColumns(r.table);
        }
        if (selectedOption.equals("Compact Columns")){
            r.compactColumns(r.table);
        }
        this.optionBox.setSelectedIndex(0);
    }//GEN-LAST:event_optionBoxActionPerformed

    private void closeMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeMenuItemActionPerformed
        this.dispose();
}//GEN-LAST:event_closeMenuItemActionPerformed

    /**
     * Run calculations on all panels.
     * @param evt
     */
    private void allCalcMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_allCalcMenuItemActionPerformed
        this.sf = new StatusFrame(this);
        RunCalculationsTask calcs = new RunCalculationsTask(this);
        for (Object o : this.resultPanels) {
            ResultPanel rp = (ResultPanel) o;
            calcs.addPanel(rp);
        }
        calcs.execute();    

    }//GEN-LAST:event_allCalcMenuItemActionPerformed

    private void currentPanelCalcMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_currentPanelCalcMenuItemActionPerformed
        this.sf = new StatusFrame(this);
        ResultPanel rp = (ResultPanel) this.tabPane.getSelectedComponent();
        RunCalculationsTask calcs = new RunCalculationsTask(this);
        calcs.addPanel(rp);
        calcs.execute();  
    }//GEN-LAST:event_currentPanelCalcMenuItemActionPerformed

    private void viewDocumentsMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_viewDocumentsMenuItemActionPerformed
        showDocumentListWindow();
}//GEN-LAST:event_viewDocumentsMenuItemActionPerformed

    private void viewAgenciesMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_viewAgenciesMenuItemActionPerformed
        graphAgencies();
    }//GEN-LAST:event_viewAgenciesMenuItemActionPerformed

    private void selectAllCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectAllCheckBoxActionPerformed
        if(selectAllCheckBox.isSelected()){
            getCurrentPanel().setSelectedCells("All");
            selectDiagonalsCheckBox.setSelected(true);
            selectLinkagesCheckBox.setSelected(true);
            selectNonLinkagesCheckBox.setSelected(true);
        } else {
            getCurrentPanel().setSelectedCells("None");
            selectDiagonalsCheckBox.setSelected(false);
            selectLinkagesCheckBox.setSelected(false);
            selectNonLinkagesCheckBox.setSelected(false);
        }
    }//GEN-LAST:event_selectAllCheckBoxActionPerformed

    private void selectDiagonalsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectDiagonalsCheckBoxActionPerformed
        getCurrentPanel().setSelectedCells("Diagonals");
    }//GEN-LAST:event_selectDiagonalsCheckBoxActionPerformed

    private void selectLinkagesCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectLinkagesCheckBoxActionPerformed
        getCurrentPanel().setSelectedCells("Linkages");
    }//GEN-LAST:event_selectLinkagesCheckBoxActionPerformed

    private void selectNonLinkagesCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectNonLinkagesCheckBoxActionPerformed
        getCurrentPanel().setSelectedCells("Non Linkages");
    }//GEN-LAST:event_selectNonLinkagesCheckBoxActionPerformed

    private void saveTDMMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveTDMMenuItemActionPerformed
        ResultPanel resultPanel = (ResultPanel) this.tabPane.getSelectedComponent();
        resultPanel.saveTDM();
    }//GEN-LAST:event_saveTDMMenuItemActionPerformed

    private void saveAsExcelMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveAsExcelMenuItemActionPerformed
        ResultPanel resultPanel = (ResultPanel) this.tabPane.getSelectedComponent();
        resultPanel.saveAsExcel();
}//GEN-LAST:event_saveAsExcelMenuItemActionPerformed

    /**
     * Displays a document list window with the search criteria specified in the
     * selected result panel.
     */
    public void showDocumentListWindow(){
        if(existsSelectedCells()){
            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            MatrixController controller = new MatrixController(this.parentOwner.getGlobals(), this.parentOwner.getGlobals().getMetaDataController());
            Vector<Vector> termList = getCurrentPanel().getSelectedTerms();
            for (int i = 0; i < termList.size(); i++) {
                Vector<String> vec = termList.get(i);
                // first position is the term for this row
                String termA = vec.get(0);
                for (int j = 1; j < vec.size(); j++) {
                    // termB is all of the selected "terms" for this row.
                    String termB = vec.get(j);
                    controller.countTerms(termA, termB, getCurrentPanel().getSearchCriteria());
                }
            }
            new AgencyGraph(this.parentOwner.getGlobals(), controller.getDocumentList(), getCurrentPanel().getSearchCriteria());
            new DocumentListWindow(controller.getDocumentList(), this.parentOwner.getGlobals(), getCurrentPanel().getSearchCriteria(), null, null);

            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }
    }

    /**
     * Display an agency graph of the selected result panel's information.
     */
    private void graphAgencies(){
        if(existsSelectedCells()){
            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            MatrixController controller = new MatrixController(this.parentOwner.getGlobals(), this.parentOwner.getGlobals().getMetaDataController());
            Vector<Vector> termList = getCurrentPanel().getSelectedTerms();
            for (int i = 0; i < termList.size(); i++) {
                Vector<String> vec = termList.get(i);
                // first position is the term for this row
                String termA = vec.get(0);
                for (int j = 1; j < vec.size(); j++) {
                    // termB is all of the selected "terms" for this row.
                    String termB = vec.get(j);
                    controller.countTerms(termA, termB, getCurrentPanel().getSearchCriteria());
                }
            }
            new AgencyGraph(this.parentOwner.getGlobals(), controller.getDocumentList(), getCurrentPanel().getSearchCriteria());
            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }
    }

    
    private ResultPanel getCurrentPanel(){
        ResultPanel rp = (ResultPanel) this.tabPane.getSelectedComponent();
        return rp;
    }

    /**
     * Are there any selected cells?
     * @return
     */
    private boolean existsSelectedCells(){
        Vector<Vector> termList = getCurrentPanel().getSelectedTerms();
        if(getCurrentPanel().listTableModel != null){
            // disabled for list view
            JOptionPane.showMessageDialog(this, "This feature is not available in List View.", "Notice", JOptionPane.INFORMATION_MESSAGE);
            return false;
        }
        if(termList == null || termList.size() == 0){
            displayNoSelectedItemsMessage();
            return false;
        }
        return true;
    }

    private void displayNoSelectedItemsMessage(){
        JOptionPane.showMessageDialog(this, "No selected items.", "Error", JOptionPane.INFORMATION_MESSAGE);
    }


    /**
     * Displays a new drawframe window.  The results of the current panel are graphed by default.
     * @param evt
     */    
    private void graphMenuItemActionPerformed(java.awt.event.ActionEvent evt){
       graphResults();
    }
    
    /**
     * Displays a new drawframe window.  
     * The filter group settings of the current panel are passed in
     * to the graph module.
     */
    private void graphResults(){
        try {
            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            ResultPanel r = (ResultPanel) this.tabPane.getSelectedComponent();

            DrawFrame drawFrame = new DrawFrame();
            drawFrame.setGapsLinkages(gapLinkages);
            
            this.parentOwner.add(drawFrame);
            drawFrame.setParentOwner(parentOwner);
            drawFrame.setFilterOptions(r.getSearchCriteria());
            drawFrame.pack();
            drawFrame.setVisible(true);
            drawFrame.setMaximum(true); // Default to max screen size.
            drawFrame.addTerms(columnNames, "circle");
            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        } catch (Exception ex) {
                                                          
        }          
    }



    private void gapColorComboActionPerformed(java.awt.event.ActionEvent evt){
        if(this.finish){
          ComboBoxRenderer cbr = (ComboBoxRenderer) gapColorCombo.getRenderer();
          this.gapsColor = cbr.currentColor;
          updatePanel();     
        }
    }
    
    private void linkagesColorComboActionPerformed(java.awt.event.ActionEvent evt){
        if(this.finish){
          ComboBoxRenderer cbr = (ComboBoxRenderer) linkagesColorCombo.getRenderer();
          this.linkagesColor = cbr.currentColor;        
          updatePanel();
        }
    }
    
    private void fontColorComboActionPerformed(java.awt.event.ActionEvent evt){
        if(this.finish){
          ComboBoxRenderer cbr = (ComboBoxRenderer) fontColorCombo.getRenderer();
          this.fontColor = cbr.currentColor;        
          updatePanel();
        }
    }    
    /**
     * User changes the font size.
     * Re-fit row and column width.
     * @param newFontSize
     */
    private void spinnerActionPerformed(int newFontSize){
        if(this.finish){
          this.fontSize = newFontSize;
          // Resize all panels
          for (Object o : this.resultPanels) {
            ResultPanel r = (ResultPanel) o;
            r.autoFitColumns(r.table);
            r.autoFitRows(r.table);
          }
          updatePanel();
        }        
    }
    
    /**
     * Repaints the current panel.
     */
    public void updatePanel(){
        if(this.finish){
            ResultPanel r = (ResultPanel) this.tabPane.getSelectedComponent();
            r.repaint();
        }
    }
    
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem allCalcMenuItem;
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JMenuItem closeMenuItem;
    private javax.swing.JPanel contentPanel;
    private javax.swing.JMenuItem currentPanelCalcMenuItem;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JComboBox fontColorCombo;
    private javax.swing.JLabel fontColorLabel;
    private javax.swing.JLabel fontSizeLabel;
    private javax.swing.JSpinner fontSpinner;
    private javax.swing.JComboBox gapColorCombo;
    private javax.swing.JLabel gapsColorLabel;
    private javax.swing.JMenuItem graphMenuItem;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JSeparator jSeparator5;
    private javax.swing.JComboBox linkagesColorCombo;
    private javax.swing.JLabel linkagesColorLabel;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JComboBox optionBox;
    private javax.swing.JPanel optionsPanel;
    private javax.swing.JMenu runCalcsMenu;
    private javax.swing.JMenuItem saveAsExcelMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JMenuItem saveTDMMenuItem;
    private javax.swing.JCheckBox selectAllCheckBox;
    private javax.swing.JCheckBox selectDiagonalsCheckBox;
    private javax.swing.JCheckBox selectLinkagesCheckBox;
    private javax.swing.JCheckBox selectNonLinkagesCheckBox;
    private javax.swing.JPanel selectPanel;
    private javax.swing.JMenu selectedCellsMenu;
    private javax.swing.JTabbedPane tabPane;
    private javax.swing.JPanel tabPanel;
    private javax.swing.JMenuItem viewAgenciesMenuItem;
    private javax.swing.JMenuItem viewDocumentsMenuItem;
    private javax.swing.JMenu viewMenu;
    // End of variables declaration//GEN-END:variables
      
    
    /**
     * Adds the tabbed panels to the results window and populates with data.
     * @param criteria
     */
    @SuppressWarnings("static-access")
    public void createPanels(){

        if(this.searchCriteria.size() == 0){
            return;
        }

        this.totalPanels = this.searchCriteria.size();
        for (int i = 0; i < this.searchCriteria.size(); i++) {
            SearchCriteria criteria = this.searchCriteria.get(i);
            // Build user-specified panels (screen 3 / search criteria)
            // Update the progress bar.
            if (this.sf != null){
                this.sf.setLabel(criteria.toString() + ": ");
            }

            CustomTableModel model = this.createTableModel(this.columnNames);
            
            this.dataModels.add(model);
            
            ResultPanel rpanel = new ResultPanel(this);
            this.createCoOccurenceTable(criteria, model, rpanel);
            JTable table = this.processTableInfo(model);
            table.setGridColor(Color.GRAY);


            // When user right-clicks or double-clicks on a cell.
            MouseClickPopup mcp = new MouseClickPopup(table, criteria, MouseClickPopup.NORMAL_TABLE, this.parentOwner.globals);
            table.addMouseListener(mcp);       

            rpanel.scrollPane.setViewportView(table);
            
            // Update the progress bar for calculations.
            
            /*  Disabled because the user can run calculations optionally.
            this.sf.setLabel("Running Calculations...");
            this.sf.setProgressBar("", 0);
            rpanel.runCalculations(model, this.gapLinkages, true);
             */
            
            rpanel.setTable(table); 
            rpanel.setTableModel(model);
            rpanel.linkagesModel = this.gapLinkages;
            rpanel.setSearchCriteria(criteria);

            this.addPanel(criteria.toString(), rpanel);
            rpanel.autoFitColumns(rpanel.table);
        }
        
        // Add a Panel to the end displaying all of the results as a list view.
        this.sf.setLabel("Generating list view...");
        this.sf.setProgressBar("", 0);
        JTable table = populateListTable(this.dataModels);
        table.setGridColor(Color.GRAY);
        ResultPanel rpanel = new ResultPanel(this);
        
//        MouseClickPopup mcp = new MouseClickPopup(table, criteria, MouseClickPopup.LIST_TABLE, this.parentOwner.globals);
//        table.addMouseListener(mcp);   

        rpanel.scrollPane.setViewportView(table);
        rpanel.setTable(table);
        rpanel.setListTableModel((CustomListTableModel)table.getModel());
        this.addPanel("List View", rpanel);
        rpanel.autoFitColumns(rpanel.table);
        
    }

    /**
     * Populates the data from the matrix controller into a table,
     * displaying the co-occurence table results.
     * @param args Hashtable Filter criteria.
     * @param CustomTableModel Where to populate the results.
     */
    private void createCoOccurenceTable(SearchCriteria criteria, CustomTableModel customTableModel, ResultPanel resultPanel){
        MatrixController matrixcontroller = new MatrixController(this.parentOwner.getGlobals(), this.columnNames, this.parentOwner.globals.getMetaDataController());
        matrixcontroller.statusFramePointer = sf;

        resultPanel.setDocumentList(matrixcontroller.getDocumentList());

        resultPanel.termDocumentMatrix = matrixcontroller.createTermDocumentMatrix(columnNames, criteria);

        int[][] coOccurenceTable = matrixcontroller.generateTable(criteria);

        // there was a problem with Lucene or the searching mechanism.
        if(coOccurenceTable == null){
            this.dispose();
        }

        for (int row=0; row < coOccurenceTable.length; row++){
            int[] rowdata = coOccurenceTable[row];
            // First column is terms
            for (int col=0; col < rowdata.length; col++){
                 if (col >= row || customTableModel.isEditable(row, col+1)){
                    customTableModel.setValueAt(coOccurenceTable[row][col], row, col+1);
                 }
            }
        }

    }

    /**
     * Returns a table with the results in a list format.
     * @param tableModels 
     * @param jurisdictions 
     */
    public JTable populateListTable(Vector<CustomTableModel> tableModels){
        
        CustomListTableModel dtm = new CustomListTableModel();
        String[] columnHeaders = new String[this.searchCriteria.size() + 1];
        columnHeaders[0] = "Term List";
        int outcolumn = 1; // data starts at column 1
        //Loop through each data table.
        for (int i = 0; i < this.searchCriteria.size(); i++) {
            CustomTableModel tableModel = (CustomTableModel) tableModels.get(i);
            String colTitle = this.searchCriteria.get(i).toString();
            columnHeaders[i+1] = colTitle;
            
            int numrows = tableModel.getRowCount();
            int numcolumns = tableModel.getColumnCount();
            
            if(listLinkages == null){
               listLinkages = new float[numrows * numcolumns][this.searchCriteria.size() + 1];
            }
            
            dtm.setNumRows(numrows * numcolumns);
            dtm.setColumnCount(this.searchCriteria.size() + 1);

            int outrow = 0;
            // Loop through each row
            for (int row = 0; row < numrows; row++) {
                String rowterm = (String) tableModel.getValueAt(row, 0);
                // Loop through each column in the row.
                for (int col = 1; col < numcolumns; col++) {
                  if(tableModel.isEditable(row, col)){
                      String colterm = tableModel.getColumnName(col);
                      Object o = tableModel.getValueAt(row, col);
                      Integer intobj = (Integer) o;
                      int value = intobj.intValue();
                      // First time through we populate column 0 with term names.
                      if(outcolumn == 1){
                         dtm.setValueAt(rowterm + " - " + colterm, outrow, 0);
                      }
                      
                        @SuppressWarnings("static-access")
                      float linkage = this.gapLinkages[row][col];
                      listLinkages[outrow][outcolumn] = linkage;
                      
                      dtm.setValueAt(value, outrow, outcolumn);
                      outrow++;
                  }
                }            
            }
            outcolumn++;
        }
        
        final ListTableCellRenderer listtablecellrenderer = new ListTableCellRenderer(listLinkages, this);
        JTable listTable = new JTable(){
            @Override
            public TableCellRenderer getCellRenderer(int row, int column) {
                return listtablecellrenderer;
            }
        };       
        dtm.setColumnIdentifiers(columnHeaders);
        listTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        listTable.setFillsViewportHeight(true);
        listTable.setEnabled(true);
        
        
        JTableHeader header = listTable.getTableHeader();
        header.setReorderingAllowed(false);
        listTable.setModel(dtm);

        dtm.setOwnerTable(listTable);
        return listTable;

    }//end method populateTable
        
    /**
     * Creates a JTable from the CustomTableModel and sets various options for the table.
     * @param model
     * @return
     */
    public JTable processTableInfo(final CustomTableModel model){
        @SuppressWarnings("static-access")
        final TableCellRenderer redcell = new RedCellRenderer(this.gapLinkages, this);
        
        JTable table = new JTable(){
            @Override
            public TableCellRenderer getCellRenderer(int row, int column) {
                return redcell;
            }
            @Override
            public boolean isCellSelected(int row, int column){
                boolean selected = super.isCellSelected(row, column);
                if(!model.isEditable(row, column)){
                   selected = false;
                }
                return selected;
            }
        };

        model.setOwnerTable(table);

        table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        table.setFillsViewportHeight(true);
        table.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);  // select single cells
        table.setCellSelectionEnabled(true);
        
        JTableHeader header = table.getTableHeader();
        header.setReorderingAllowed(false);
        table.setModel(model);
        return table;
    }
    

    /**
     * Creates and Returns a CustomTableModel given an array of column titles.
     * @param names
     * @return
     */
    private CustomTableModel createTableModel(String[] names){
        
        if (names == null){
            names = this.columnNames;            
        }
        
        int padding = 0;  // add blank columns to fill in the viewport
        int numberofcolumns = names.length + padding;
        
        CustomTableModel customTableModel;
        customTableModel = new CustomTableModel(names.length, numberofcolumns, padding);        

        // Set row count = number of terms.
        customTableModel.setRowCount(names.length);
        
        // Shift all elements right by one because column 1 will
        // be a mirror of the heading.
        String[] columnTitles = new String[numberofcolumns + 1];
        for (int i=0; i<=numberofcolumns; i++){
            if (i == 0){
                columnTitles[i] = "";
            } else if (i <= (numberofcolumns - padding)){
                columnTitles[i] = names[i - 1];
            } else {
                columnTitles[i] = "";
            }            
        }
        
        // Set the column titles.
        customTableModel.setColumnIdentifiers(columnTitles);
             
        // Set first column values
        for (int row=0; row<names.length; row++){
            String value = names[row];                                            
            customTableModel.setValueAt(value, row, 0); //value, row, column
        }
        
        // Populate uneditable cells with a --- value.
        for (int row=0; row<customTableModel.getRowCount(); row++){
            for (int col=0; col<customTableModel.getColumnCount(); col++){
                boolean b = customTableModel.isEditable(row, col);
                if(b == false && col > 0){
                    customTableModel.setValueAt("---", row, col);
                }                
            }
        }

        return customTableModel;
    }
    
    
    /** Returns the table data in a two-dimensional String array. */
    private String[][] getTableData(CustomTableModel ctm){
        String[][] tableData = 
                new String[ctm.getRowCount()][ctm.getColumnCount()];
        
        for (int row=0; row < ctm.getRowCount(); row++){
            for (int col=1; col < ctm.getColumnCount(); col++){
                // Retrieve cell value
                Object cellValue = ctm.getValueAt(row, col);
                if (cellValue == null){
                    
                    return null;
                } else {
                    String cellData = (String) ctm.getValueAt(row, col);
                    tableData[row][col] = cellData;  
                }
            }
        }

        return tableData;
    }

    @SuppressWarnings("static-access")
    public void setLinkages(float[][] in_linkages){
        this.gapLinkages = in_linkages;
    }
    
    public void setColumnNames(String[] columnNames){
        this.columnNames = columnNames;
    }
    
    public void addPanel(String title, ResultPanel rp){
        tabPane.addTab(title, rp );
        this.resultPanels.add(rp);
    }
    
    /* Puts the frame in the middle of the screen. */
    public void setCenter(){
        Rectangle r = this.parentOwner.getBounds();
        int width = this.getWidth();
        int height = this.getHeight();
        // attempt to center the screen on the page
        this.setLocation((r.width - width) / 2, (r.height - height) / 2);
    }
       
    
    /**
     * Called from StatusFrame.  User presses the cancel button during run calculations.
     */
    public void cancel(){
        // If the cancel button is pressed from running calcs, then we don't want
        // to destroy this frame.
        if(this.finish){
            
        }else{
            this.task.cancel(true);
            this.dispose(); 
        }
    }
    
    
    
   /*********************** Custom Classes ******************************/
    
    
   /**
    * 
    */ 
   public static class CustomTableModel extends DefaultTableModel{
       
        int padding = 0; // default
        int columncount = 0; // default
        int rowcount = 0;
        boolean[][] selectedCells;
        JTable ownerTable;

        public CustomTableModel(int rows, int columns, int padding){
            this.columncount = columns;
            this.padding = padding;
            this.rowcount = rows;
            // selectedCells is the same size as the entire table
            selectedCells = new boolean[rows][columns+1];
            // init all to false
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < columns+1; j++) {
                    selectedCells[i][j] = false;
                }
            }
        }

        public void setOwnerTable(JTable table){
            this.ownerTable = table;
        }
        
        public Float getFloatValue(int row, int column){
            Object o = this.getValueAt(row, column);
            String s = (String) o;
            return Float.valueOf(s);
        }

        public Integer getIntValue(int row, int column){
            Object o = this.getValueAt(row, column);
            return (Integer) o;
        }
        
        @Override
        /**
         * Handles the actual ability to enter values in the cell
         */ 
        public boolean isCellEditable(int row, int col) {         
            return false; 
        }        
        
        /** 
         * Whereas this method simply wants to know whether to display "---"
         */
        public boolean isEditable(int row, int col){
            if (col >= row+1 && col <= (columncount - padding)) {
                return true;
            } else {
                return false;
            }                  
        }

        /**
         * Custom method for settings this cell as "selected".
         * Does not relate to the default table selection methods in any way.
         * @param r
         * @param c
         * @param b
         */
        public void setSelected(int row, int col, boolean b){
            this.selectedCells[row][col] = b;
        }

        /**
         * If this cell is set as selected, or is actually selected by the user
         * via the default cell functionality.
         * @param row
         * @param col
         * @return
         */
        public boolean isSelected(int row, int col){
            boolean thisSelected =  this.selectedCells[row][col];
            if(this.ownerTable != null){
                boolean defaultSelected = this.ownerTable.isCellSelected(row, col);
                if(defaultSelected){
                   thisSelected = true;
                }
            }
            return thisSelected;
        }

        /**
         * Sets all cells as selected.
         */
        public void selectAllCells(){
            for (int i = 0; i < rowcount; i++) {
                for (int j = 1; j < columncount+1; j++) {
                    if(isEditable(i, j)){
                        setSelected(i, j, true);
                    }
                }
            }
        }
        /**
         * Sets all cells as unselected.
         */
        public void unSelectAllCells(){
            for (int i = 0; i < rowcount; i++) {
                for (int j = 1; j < columncount+1; j++) {
                    setSelected(i, j, false);
                }
            }
        }
        /**
         * Selects the diagonals.  Unselects if already selected. 
         */
        public void selectDiagonals(){
            for (int i = 0; i < rowcount; i++) {
                for (int j = 1; j < columncount+1; j++) {
                    if((i+1) == j){
                        boolean isSelected = selectedCells[i][j];
                        isSelected = !isSelected;
                        setSelected(i, j, isSelected);
                    }
                }
            }
        }
        /**
         * Selects/unselects cells marked as linkages.
         */
        public void selectLinkages(){
            for (int i = 0; i < rowcount; i++) {
                for (int j = 1; j < columncount+1; j++) {
                    if(isEditable(i, j)){
                        int cell_value = this.getIntValue(i, j);
                        float link_value = gapLinkages[i][j];
                        if(cell_value > 0 && link_value > 0){
                            boolean isSelected = selectedCells[i][j];
                            isSelected = !isSelected;
                            setSelected(i, j, isSelected);
                        }
                    }
                }
            }
        }
        /**
         * Selects/unselects cells that are not marked as linkages, but have
         * a value greater than 0.  Doesn't select diagonals.
         */
        public void selectNonLinkages(){
            for (int i = 0; i < rowcount; i++) {
                for (int j = 1; j < columncount+1; j++) {
                    if(isEditable(i, j) && (j > (i+1))){
                        float link_value = gapLinkages[i][j];
                        int cell_value = this.getIntValue(i, j);
                        if(cell_value > 0 && link_value == 0){
                            boolean isSelected = selectedCells[i][j];
                            isSelected = !isSelected;
                            setSelected(i, j, isSelected);
                        }
                    }
                }
            }
        }
        /**
         * Checks every cell that's selected and returns the corresponding two
         * terms that go with that cell's value.  Returns null if no selected items.
         * @return
         */
        public Vector<Vector> getSelectedTermsFromCells(){
            Vector<Vector> terms = new Vector<Vector>();
            for (int i = 0; i < rowcount; i++) {
                Vector<String> rowVec = new Vector<String>();
                String rowTerm = (String) this.getValueAt(i, 0);
                rowVec.add(rowTerm);
                for (int j = 1; j < columncount+1; j++) {
                    // if cell is set as "selected" or is actually selected
                    if(isSelected(i, j)){
                        String colTerm =  (String) this.columnIdentifiers.get(j);
                        rowVec.add(colTerm);
                    }
                }
                if(rowVec.size() > 1){
                    terms.add(rowVec);
                }
            }
            if(terms.size() > 0){
                return terms;
            } else {
                return null;
            }
        }
    }
   
   public class CustomListTableModel extends DefaultTableModel{

       JTable ownerTable;

       public CustomListTableModel(){
       }
          
        @Override
        /**
         * Handles the actual ability to enter values in the cell
         */ 
        public boolean isCellEditable(int row, int col) {         
            return false; 
        }
        
        public boolean isEditable(int row, int col){
            if (col > 0) {
                return true;
            } else {
                return false;
            }                  
        }
        public void setOwnerTable(JTable t){
            this.ownerTable = t;
        }

        /**
         * Checks every cell that's selected and returns the corresponding two
         * terms that go with that cell's value.  Returns null if no selected items.
         * @return
         */
        public Vector<Vector> getSelectedTermsFromCells(){
            Vector<Vector> terms = new Vector<Vector>();
            int rowcount = this.getRowCount();
            for (int i = 0; i < rowcount; i++) {
                Vector<String> rowVec = new Vector<String>();
                if(this.ownerTable.isCellSelected(i, 0)){
                    String cellValue = (String) this.getValueAt(i, 0);
                    String[] cellTerms = cellValue.split("-");
                    for (String t : cellTerms) {
                        rowVec.add(t.trim());
                    }
                }
                if(rowVec.size() > 1){
                    terms.add(rowVec);
                }
            }
            if(terms.size() > 0){
                return terms;
            } else {
                return null;
            }
        }

    }
   
   /**
    * Custom renderer class for the "list view" table.
    */
   class ListTableCellRenderer extends DefaultTableCellRenderer {
        
        ResultsFrame rfPointer; // keep global variables like color and fonts here
        float[][] linkages; // linkages in a format that this renderer can use
                    
        public ListTableCellRenderer() {
            
        }

        private ListTableCellRenderer(float[][] gapLinkages, ResultsFrame rf) {
            this.linkages = gapLinkages;
            this.rfPointer = rf;
        }
       
       @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
                boolean hasFocus, int row, int column) {
            
            Component cell = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            
            int fontSize = rfPointer.fontSize;
            
            // Set the column font here also.
            JTableHeader header = table.getTableHeader();
            Font defaultColumnHeaderFont = new Font(Font.DIALOG, Font.PLAIN, fontSize);
            header.setFont(defaultColumnHeaderFont);
            
            Font defaultFont = new Font(Font.DIALOG, Font.PLAIN, fontSize);
            cell.setFont(defaultFont);
            
            cell.setBackground(Color.WHITE);
            cell.setForeground(this.rfPointer.fontColor);
            
            if (column > 0){
                // Set the background color if there is a gap or a linkage.
                if (value instanceof Integer){
                    Integer v = (Integer) value;
                    int cellValue = v.intValue();

                    if (this.linkages[row][column] > 0){
                       if (cellValue == 0){
                          cell.setBackground(rfPointer.gapsColor);
                       }else {                  
                         cell.setBackground(rfPointer.linkagesColor);
                       }
                    }
                }
            }
            
            
            if (hasFocus){
                setBorder(BorderFactory.createMatteBorder(2, 2, 2, 2, Color.CYAN)); 
            }

            // blue green color
            Color selectColor = new Color(0, 137, 210);

            if (isSelected){
                Font nf = new Font(cell.getFont().toString(), Font.BOLD, cell.getFont().getSize() + 1);
                setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, selectColor));
                cell.setFont(nf);
            } else {
                Font nf = new Font(cell.getFont().toString(), Font.PLAIN, cell.getFont().getSize());
                cell.setFont(nf);
            }
            
            // Set hover text            
            Object rowTitleObj = table.getValueAt(row, 0);
            String rowTitle = (String) rowTitleObj;
            String colTitle = table.getModel().getColumnName(column);
            
            this.setToolTipText(rowTitle + " - " + colTitle);
            
            return cell;               
       }
   }
   
    /**
     * Custom table cell renderer used in each panel.
     */
   class RedCellRenderer extends DefaultTableCellRenderer {
       
        float[][] linkages;
                
        ResultsFrame rfPointer; // keep global variables like color and fonts here
        
        public RedCellRenderer() {
            
        }

        private RedCellRenderer(float[][] gapLinkages, ResultsFrame rf) {
            this.linkages = gapLinkages;
            this.rfPointer = rf;
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
                boolean hasFocus, int row, int column) {
            
            Component cell = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

            CustomTableModel model = (CustomTableModel) table.getModel();
            boolean customIsSelected = model.isSelected(row, column);

            int fontSize = rfPointer.fontSize;
            
            // Set the column font here also.
            JTableHeader header = table.getTableHeader();
            Font defaultColumnHeaderFont = new Font(Font.DIALOG, Font.PLAIN, fontSize);
            header.setFont(defaultColumnHeaderFont);
            
            Font defaultFont = new Font(Font.DIALOG, Font.PLAIN, fontSize);
            cell.setFont(defaultFont);
            
            cell.setBackground(Color.WHITE);
            cell.setForeground(this.rfPointer.fontColor);
            
            // Set the background color if there is a gap or a linkage.
            if (value instanceof Integer){
                Integer v = (Integer) value;
                int cellValue = v.intValue();

                if (this.linkages[row][column] > 0){
                   if (cellValue == 0){
                      cell.setBackground(rfPointer.gapsColor);
                   }else {                  
                     cell.setBackground(rfPointer.linkagesColor);
                   }
                }
            }

            // These cells are the same terms.
            if (row+1 == column){
                cell.setBackground(Color.LIGHT_GRAY);
            }

            // blue green color
            Color selectColor = new Color(0, 137, 210);

            if (hasFocus){
                setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, selectColor));
            }
            
            if (isSelected || customIsSelected){
                setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, selectColor));
                Font bf = new Font(cell.getFont().toString(), Font.BOLD, cell.getFont().getSize());
                cell.setFont(bf);
            } else {
                Font nf = new Font(cell.getFont().toString(), Font.PLAIN, cell.getFont().getSize());
                cell.setFont(nf);
            }

            
            // Set hover text            
            Object rowTitleObj = table.getValueAt(row, 0);
            String rowTitle = (String) rowTitleObj;
            String colTitle = table.getModel().getColumnName(column);
            
            this.setToolTipText("(row " + row + ", column " + column + ") " + rowTitle + " - " + colTitle);
            
            return cell;            
        }
    }
    
   class Task extends SwingWorker<Void, Void> {
        /*
         * Main task. Executed in background thread.
         */
        
        private Task() {
        }
        
        @Override
        public Void doInBackground() {
            createPanels();
            return null;
        }

        /*
         * Executed in event dispatching thread
         */
        @Override
        public void done() {
            setVisible(true);
            if (this.isCancelled() == false){
                // The status frame will dispose itself upon cancellation.
                sf.dispose();
            }
        }
    }
   
   class RunCalculationsTask extends SwingWorker<Void, Void> {
        /*
         * Will run the calculations on all panels on just one panel.
         */
        ResultsFrame rf;
        Vector ResultPanels; // list of panels to run calcs for
        
        public RunCalculationsTask(ResultsFrame rf){
           this.rf = rf;
           this.ResultPanels = new Vector();
        }
        
        public void addPanel(ResultPanel r){
            this.ResultPanels.add(r);
        }
        
        @Override
        public Void doInBackground() {
            for (Object object : ResultPanels) {
                ResultPanel rp = (ResultPanel) object;
                rp.runCalculations(rp.tableModel, rp.linkagesModel, true);
            }

            return null;
        }

        /*
         * Executed in event dispatching thread
         */
        @Override
        public void done() {
            if (this.isCancelled() == false){
                // The status frame will dispose itself upon cancellation.
                this.rf.sf.dispose();
            }
        }
    }
    
   class ComboBoxRenderer extends JLabel implements ListCellRenderer {
        
         Hashtable colorTable;
         public String[] colorChoices = {
                "BLACK", 
                "BLUE", 
                "CYAN", 
                "DARK GRAY", 
                "GRAY", 
                "GREEN", 
                "LIGHT GRAY",
                "MAGENTA",
                "ORANGE",
                "PINK",
                "RED",
                "WHITE",
                "YELLOW"            
         };
        
        Color[] colors = {
            Color.BLACK, 
            Color.BLUE, 
            Color.CYAN, 
            Color.DARK_GRAY, 
            Color.GRAY, 
            Color.GREEN, 
            Color.LIGHT_GRAY,
            Color.MAGENTA,
            Color.ORANGE,
            Color.PINK,
            Color.RED,
            Color.WHITE,
            Color.YELLOW
        };
        
        Color currentColor = null;
        
        public ComboBoxRenderer() {
            colorTable = new Hashtable();
            for (int i = 0; i < colorChoices.length; i++) {
              colorTable.put(colorChoices[i], colors[i]);
            }

            setOpaque(true);
            setHorizontalAlignment(LEFT);
            
        }

        /*
         *
         */
        @Override
        public Component getListCellRendererComponent(
                                           JList list,
                                           Object value,
                                           int index,
                                           boolean isSelected,
                                           boolean cellHasFocus) {
            
            String selectedColor = value.toString();
            setText(selectedColor);
            Color c = (Color) colorTable.get(selectedColor);
            setForeground(c);
            if (isSelected && (selectedColor.equals("") == false)) {
                this.currentColor = c;
                setForeground(this.currentColor);
                setBackground(this.currentColor.darker());
                if(c == Color.WHITE){
                   setBackground(c.darker()); 
                }
                if(c == Color.BLACK){
                   setBackground(Color.WHITE); 
                }                
            } else{
                setBackground(Color.WHITE);
            }            
            return this;
        }
    }
   
   class SpinnerListener implements ChangeListener{
       
       ResultsFrame rfPointer; 
       
       SpinnerListener(ResultsFrame rf){
           super();
           this.rfPointer = rf;
       }
       
        @Override
        public void stateChanged(ChangeEvent e) {
            JSpinner mySpinner = (JSpinner)(e.getSource());
            int newfontsize = ((Integer) mySpinner.getValue()).intValue();
            this.rfPointer.spinnerActionPerformed(newfontsize);
        }
       
   }
    
    
}
